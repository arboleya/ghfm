// Generated by CoffeeScript 1.6.3
var css, fs, get_css_paths, index, path, publ1c, register, request, save, template;

fs = require('fs');

path = require('path');

request = require('request');

register = require('./register');

publ1c = path.join(__dirname, '..', 'public');

index = path.join(publ1c, 'index.html');

template = path.join(publ1c, 'template.html');

template = fs.readFileSync(template, 'utf-8');

css = [];

module.exports = function(filepath, done) {
  var buffer, config_path, data, token, url;
  buffer = fs.readFileSync(filepath, 'utf-8');
  config_path = path.join(__dirname, 'user.oauth.json');
  if (!fs.existsSync(config_path)) {
    return register(function() {
      return module.exports(filepath, done);
    });
  }
  token = require(config_path).token;
  url = 'https://api.github.com/markdown?access_token=' + token;
  data = {
    text: buffer,
    mode: 'markdown'
  };
  return request.post(url, {
    json: data,
    encoding: 'utf-8'
  }, function(req, res) {
    if (~'401 Unauthorized | 403 Forbidden'.indexOf(res.headers.status)) {
      return register(function() {
        return module.exports(filepath, done);
      });
    } else {
      save(res.body);
      return done(res.body);
    }
  });
};

get_css_paths = function(done) {
  return request('http://github.com', function(err, res, body) {
    if (err === null && res.statusCode === 200) {
      css = body.match(/https?:\/\/github.+github2?-[0-9a-z]+\.css/g);
      return done();
    }
  });
};

save = function(html) {
  var buffer;
  if (css.length === 0) {
    return get_css_paths(function() {
      return save(html);
    });
  }
  buffer = template.replace('~CONTENT', html);
  buffer = buffer.replace('~CSS1', css[0]);
  buffer = buffer.replace('~CSS2', css[1]);
  return fs.writeFileSync(index, buffer);
};

/*
//@ sourceMappingURL=render.map
*/
